## 题目链接
以下暂为官方题解

### 1001 String

假设原始的字符串 数组为A，首先将A中的每个字符串都进行翻转，得到字符串数组B，然后，将A和B按字典序排序。
对于一个查询来说有一个前缀p和后缀s， 所有包含前缀p的字符串在A中是连续的，可通过二分求出该区间 设为[Lp,Rp]，同样，所有包含后缀s的字符串在B中也是连续的，设为[Ls,Rs]

接下来只需求解 有多少个字符串前缀是在[Lp,Rp] 同时后缀在[Ls,Rs]。对于每个字符串，假设在A中是第x个，在B中是第y个 ，那么我们只需要判断有多少个字符串 Lp<=x<=Rp 同时 Ls<=y<=Rs

该问题转化为，有一些点（每个字符串相当于一个点，x是按前缀排完序的位置，y是按后缀排序），现给定一些矩形（每个查询可转化为 Lp<=x<=Rp,Ls<=y<=Rs），问矩形中包含多少个点，该问题是经典的矩形覆盖问题，线段树+扫描线 即可求出。

按上述方法求出后，会存在重叠的问题 。如有一个字符串 aaa 查询如果为 aa aa的话也会查到 aaa。 那么我们需要进行去重，可直接对查询的前缀或者后缀做一个遍历，枚举重叠的长度，然后再哈希判断是否存在这样的原始字符串即可。

时间复杂度 O(nlog(n)+∣S∣)

避免hash可以离线暴力在字典树上建线段树，查询在字典树上找到后缀对应节点查找前缀区间和。空间O(∣S∣log(n))。时间复杂度 O(nlog(n)+∣S∣)

也可以直接hash离线做。

### 1002 Mindis

很不幸不总是中垂线上的点取到最小值，考虑点在圆上的极端情况。
做P点关于圆的反演点P',OPD与ODP'相似，相似比是|OP| : r。

Q点同理。

极小化PD+QD可以转化为极小化P'D+Q'D。

当P'Q'与圆有交点时，答案为两点距离，否则最优值在中垂线上取到。

时间复杂度 O(1)

也有代数做法，结论相同。

优秀的黄金分割三分应该也是可以卡过的。

### 1003 Inversion

需要统计的区间最大值次数是O(nlog(n))级别的。
时间复杂度 O(nlog(n))。

优秀的多个O(log(n))的做法也是可以卡过的。

这里介绍一下优雅的暴力做法。将A数组按值从大到小排序，对于每个下标i暴力找到最大的不被i整除的数。

时间复杂度 O(nlog(n))。

### 1004 Similarity

没有贡献相似度的点把树分割成多棵树。相似度要达到n−3转化为最多可以分割成三棵树。
两颗树分别枚举两条断边hash成三棵子树。寻找两个集合中是否存在相同的hash值。

时间复杂度 O(n​3​​log(n))

### 1005 WrongStatement

放置完domino后的空隙和最终空隙之间的x，y轴的差值均为为偶数。
每个1*2的domino的两头可以交换一个空隙，可以将其当作一条边。问题就是计算放置完domino且空出来的位置和@连通的方案数。

定义f​i,j,S,mask​​表示处理到i行j列可能成为空余位置间的连通性状态和轮廓线上未填放空格状态的方案数。

f​n,m,connect,0​​即为答案，其中connect表示产生的空隙和目标空隙连通。

时间复杂度 O(n∗m∗2​m​​∗S)，S为4个格子最多两个独立插头的状态数，约为152种。

1006 Gumballs&Dungeons

状压dp，先对每个杀死的怪物状态S，bfs预处理出能获得的4种buff数量。设立状态F​s,i,j​​表示杀死的怪物状态S，攻击力i，防御力j的情况下的最大生命值。由于buff都是增益的，因此转移的时候肯定会尽可能把魔法值用光，每个状态下能使用的最大魔法次数为 Mc=⌊​Mm​​MP​total​​​​⌋ 。那么转移到新状态S’的时候能多使用多少次魔法就可以计算出来，增加攻击力，防御力，生命值的buff总数值S​Ab​​,S​Db​​,S​Hb​​也可以计算出来，枚举一下加x次攻击力，y次防御力，剩下就都加到生命值上。状态转移方程为：
f​s​′​​,i+x∗Am+S​Ab​​,j+y∗Dm+S​Db​​​​=max(f​s,i,j​​+S​Hb​​+(Mc−x−y)∗Hm)

时间复杂度 O(2​S​​∗H​4​​)，其中S为7，H为20。

### 1007 GCDispower

考虑离线做法，固定右端点r，维护每个左端点l的答案，那么对于一个新加进来的Ar, 枚举他的倍数，找出Ai满足，i < r的位置，那么问题相当于所有Ai / Ar之后，对于任意一组(Ai, Aj)满足i < j && gcd(A[i], A[j]) == 1，那么对于左端点1到i的答案数就要加Ar，因此在这些Ar的倍数这些位置，每个位置x对左端点在[1, x]位置的贡献为x <= i < r这些Ai / Ar的互质个数，这个可以在从右往左扫的过程中，利用在质因子上做容斥求出，然后用树状数组维护一下答案即可。由于给的是一个全排列，每个数字枚举他的倍数均摊下来是nlog(n)。
总体的时间复杂度是O(nlog​2​​n)

### 1008 Kirinriki

标题提示我们回文串。
两个不重合的子串向中心一起延长会形成奇偶长度两种合串。

枚举一下中心向外延伸，如果和超过了阈值弹掉中心处的位置。双指针维护。

时间复杂度O(n​2​​)

另解：

枚举[1,i],[j,n]用同样方法往内缩。

时间复杂度O(n​2​​)

### 1009 Influence

造题的时候还没有操作2，想了各种做法，然后发现是个动态点分治原题，然后就加了个操作2。
考虑一个数组支持两个操作：单点权值修改和全局加权值*w。

修改单点权值时可以单点累加个sumw*(oldvalue-newvalue)，这样就可以把权值当作最新的值了。

提供一个动态点分治的做法。

贡献分为两块，部分从点分治树子树过来，这部分是真实的。另一部分原作法是维护条数的，但现在在时间上不具有累加性。每条边属于O(log(n))块，修改边权时相当于一颗子树的sumw会对另一颗子树产生影响。树状数组维护。

时间复杂度O(nlog​2​​n)

也可以在树链剖分的基础上增加回溯值的维护。

### 1010 Gameia

如果Bob能把这棵树分成若干两个一组的点对，那么Bob取得胜利，否则Alice获胜。
如果原树不存在两两匹配的方案，Alice从树叶开始，每次都染树叶父节点，Bob被迫只能不断的染叶子，Bob退化成一般玩家，因为Bob做不做小动作都不会逆转局势，总会出现一个时间点Bob没办法跟上Alice的节奏而让Alice染到一个周围都已被染色的孤立点（因为原树不存在两两匹配的方案）
如果原树存在两两匹配的方案，而且Bob的小动作次数也足以把原树分成两两的点对，那么Bob显然获胜。
如果原树存在两两匹配的方案，而Bob的小动作不足以把树分成两两的点对，Alice一定获胜，因为每次染某个叶子节点（该节点为其父节点的唯一子节点），Alice总能迫使Bob不断的做小动作以保证剩下的树不会出现奇数节点的树，且每次小动作割出一个点对（包含Alice刚染的点），最后有两种情况。
出现某个结点有>=2个子节点为叶子节点。Alice染这个点，Bob跟不上Alice的节奏，出现孤点，Ailice取胜
否则整个过程一定会持续到树被染光或者Bob被Alice掏空导致做不了小动作进而被迫割出一块size为奇数的子树（这棵树显然没办法两两匹配）而败北。
Bob被允许“任意时刻”做小动作看似很厉害其实很鸡肋，把问题改成“Bob只能在游戏开始之前做小动作”会得到同样的结论。
“氪不改命，玄不救非”
时间复杂度 O(n)

### 1011 Classes

签到题。
唯一的trick是要判一下Venn图上每个部分不小于0。

### 1012 Typesetting

在固定某个宽度的前提下，预处理以第i个单词开始，一行内最多能放置的单词个数。因为页面宽度，图片的左右边距都固定了，所以只要预处理这3种宽度。用f​i,j​​表示从第i个单词开始，占用2​j​​行能放置的最大单词个数。图片最多将n个单词划分成3部分，每部分都使用倍增即可完成快速查询。为了方便，可以添加第n+1个单词，单词长度大于页面宽度且该单词不占据行。
时间复杂度 O((n+q)log(n))

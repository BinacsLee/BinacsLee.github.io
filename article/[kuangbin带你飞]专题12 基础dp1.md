## 链接 https://vjudge.net/contest/68966

A 最大不相交子段和  设 dp[i][j] 为前 j 个数字分成 i 段的最大和
    
    dp[i][j]表示的是第j个数字_在_第i个子序列时的当前最优值 (其中最后一个段i包含a[j] (这很关键))
    dp[i][j]=max(dp[i][j-1],max(dp[i-1][k]))+a[j] (i-1<=k<=j-1)
    
    对于当前的a[j]这个数字 如果把他放到第i个子序列中有两种情况 
    一个是他作为第i个子序列的第一个数字 另一个就是不作为第一个数字
    作为第一个数字的时候是 max(dp[i-1][k] + a[j]) 1<=k<i 的意思是从之前的所有中找到i-1个子序列的最大值+当前的值
    不做为第一个的时候那么他前面的那个数字一定是i序列的 那么当前的值是dp[i][j-1] + a[j]
    

<br>
B 输入序列中出现次数最多的值 排序即可
<br>

C 立方体旋转加入序列 dp[i]为到第i个立方体的最大高度 ..
<br>

D 做家庭作业 二进制状态dp 
<br>

E jumpiing 最大的上升子段的和 dp[i]为到这个位置时可获得的最大值 最后扫一遍
<br>

F 存钱罐 完全背包问题 因为要求至少有多少且总重一定 故初始化INF dp取min
<br>

G 免费馅饼问题 金字塔形逆推  最后输出dp[0][6]
<br>

H 简单dp 一人取所花时间和两人连取所花时间 dp[i]为到第i人为止最小时间 输出dp[n]
<br>

I 最少拦截系统 换个思路想是最长严格上升子序列 扫一遍输出最大值 (可以边输入边处理)
<br>

J 从一组数据中找到最多的可满足体重越大速度越小的数据 输出最多有多少个 先按体重排序后dp(最长上升子序列)  dp[i]为以i结尾的最大序列长度 所以要扫一遍
<br>

K todo
<br>

L 最长公共子序列模版题
<br>

M help jimmy 有点复杂 按板高度排序 dp[i][2] 第二维0和1分别表示从排序后第i个板的左/右处的最小值 
最后输出min(dp[n+1][0],dp[n+1][1]) 当然n+1记录老鼠位置 即st[n+1].l=st[n+1].r
<br>

N 最长上升子序列模版题..
<br>

O 给出的一系列的数字 可以看成一个双向队列 每次只能从队首或者队尾出队 第n个出队就拿这个数乘以n 
最后将和加起来 求最大和  思路：由里向外逆推区间(区间dp) 
<br>

P cheese问题 dfs记忆化搜索典型
<br>

Q 最大对称矩阵 对称轴为左下-右上 dp[i][j]为以 ij为左下端点的矩阵最大值 基本dp稍变复杂点
<br>

R milking time 排序 记录dp 再扫一遍输出最大值 
<br>

S todo
<br><br>
